import {
  createSlice,
  createAsyncThunk,
  type PayloadAction,
} from "@reduxjs/toolkit";
import type { RootState } from "../../app/store";

// --- SECTION 1: TYPE DEFINITIONS ---
// Defining clear interfaces for our data is a best practice.
// It provides type safety and serves as documentation for the shape of our state.

export interface Site {
  id: number;
  name: string;
  location?: string; // Optional property
}

// Data needed to create a new site (ID is generated by the server)
export interface NewSiteData {
  name: string;
  location?: string;
}

// Data needed to update a site (ID is required to identify the site)
export interface UpdateSiteData extends NewSiteData {
  id: number;
}

// --- SECTION 2: STATE DEFINITION ---
// This interface defines the complete shape of our 'sites' slice.

interface SitesState {
  sites: Site[]; // The array of site objects

  // Status for the initial fetch (Read operation)
  status: "idle" | "loading" | "succeeded" | "failed";
  error: string | null | undefined; // Error message specifically for the fetch

  // A single, unified status for Create, Update, and Delete (CUD) operations.
  // This is a great pattern to simplify state when you don't need to track
  // multiple operations at once (e.g., deleting two sites simultaneously).
  operationStatus: "idle" | "loading" | "succeeded" | "failed";
  operationError: string | null | undefined;
}

const initialState: SitesState = {
  sites: [],
  status: "idle",
  error: null,
  operationStatus: "idle",
  operationError: null,
};

// It's good practice to define the base URL as a constant.
const API_BASE_URL = "http://api/v1";

// --- SECTION 3: ASYNC THUNKS ---
// Thunks handle all asynchronous logic, like API calls.
// They keep this logic out of our components and centralized in the slice.

// Thunk to FETCH all sites
export const fetchSites = createAsyncThunk<
  Site[],
  void,
  { rejectValue: string }
>(
  "sites/fetchSites", // Action type prefix
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch(`${API_BASE_URL}/sites`);
      if (!response.ok) {
        // If the server responds with an error, reject with a message
        return rejectWithValue("Failed to fetch sites.");
      }
      return await response.json(); // This will be the `action.payload` on success
    } catch (e: any) {
      // If the network request itself fails, reject with the error message
      return rejectWithValue(e.message);
    }
  }
);

// Thunk to CREATE a new site
export const createSite = createAsyncThunk<
  Site,
  NewSiteData,
  { rejectValue: { message: string } }
>("sites/createSite", async (newSiteData, { rejectWithValue }) => {
  try {
    const response = await fetch(`${API_BASE_URL}/sites`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(newSiteData),
    });
    if (!response.ok) {
      // Here, we expect the server to send back a JSON with an error message
      return rejectWithValue(await response.json());
    }
    return await response.json();
  } catch (e: any) {
    return rejectWithValue({ message: e.message });
  }
});

// Thunk to UPDATE an existing site
export const updateSite = createAsyncThunk<
  Site,
  UpdateSiteData,
  { rejectValue: { message: string } }
>("sites/updateSite", async (updateData, { rejectWithValue }) => {
  try {
    // Separate the ID from the rest of the data for the request body
    const { id, ...payload } = updateData;
    const response = await fetch(`${API_BASE_URL}/sites/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      return rejectWithValue(await response.json());
    }
    return await response.json(); // The updated site from the server
  } catch (e: any) {
    return rejectWithValue({ message: e.message });
  }
});

// Thunk to DELETE a site
export const deleteSite = createAsyncThunk<
  number,
  number,
  { rejectValue: string }
>("sites/deleteSite", async (siteId, { rejectWithValue }) => {
  try {
    const response = await fetch(`${API_BASE_URL}/sites/${siteId}`, {
      method: "DELETE",
    });
    if (!response.ok) {
      return rejectWithValue("Failed to delete the site.");
    }
    // On success, return the original `siteId`. The reducer will use this
    // to know which site to remove from the state array.
    return siteId;
  } catch (e: any) {
    return rejectWithValue(e.message);
  }
});

// --- SECTION 4: SLICE DEFINITION ---
// The slice brings together the state, reducers, and actions.

const sitesSlice = createSlice({
  name: "sites",
  initialState,
  // `reducers` are for synchronous actions that directly modify state.
  reducers: {
    // This reducer allows us to reset the operation status from any component.
    resetOperationStatus: (state) => {
      state.operationStatus = "idle";
      state.operationError = null;
    },
  },
  // `extraReducers` handle actions defined outside the slice, like our async thunks.
  extraReducers: (builder) => {
    // --- DRY Pattern for CUD operations ---
    // This is a clever way to handle pending/rejected states for all CUD thunks.
    const operationThunks = [createSite, updateSite, deleteSite];
    operationThunks.forEach((thunk) => {
      builder
        .addCase(thunk.pending, (state) => {
          // When any of these thunks start, set the status to 'loading'.
          state.operationStatus = "loading";
          state.operationError = null;
        })
        .addCase(thunk.rejected, (state, action) => {
          // When any of these thunks fail, set status to 'failed' and store the error.
          state.operationStatus = "failed";
          const payload = action.payload as
            | { message: string }
            | string
            | undefined;
          // Robustly get the error message, whether it's an object or a string.
          if (typeof payload === "object" && payload?.message) {
            state.operationError = payload.message;
          } else if (typeof payload === "string") {
            state.operationError = payload;
          } else {
            state.operationError =
              action.error.message || "An unknown error occurred.";
          }
        });
    });

    // --- Reducers for specific thunk lifecycle stages ---
    builder
      // Fetching sites
      .addCase(fetchSites.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchSites.fulfilled, (state, action: PayloadAction<Site[]>) => {
        state.status = "succeeded";
        state.sites = action.payload; // Replace the sites array with the fetched data
      })
      .addCase(fetchSites.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload || action.error.message;
      })
      // Creating a site (handles the successful case)
      .addCase(createSite.fulfilled, (state, action: PayloadAction<Site>) => {
        state.operationStatus = "succeeded";
        state.sites.push(action.payload); // Add the new site to the array
      })
      // Updating a site (handles the successful case)
      .addCase(updateSite.fulfilled, (state, action: PayloadAction<Site>) => {
        state.operationStatus = "succeeded";
        const index = state.sites.findIndex((s) => s.id === action.payload.id);
        if (index !== -1) {
          state.sites[index] = action.payload; // Replace the old site with the updated one
        }
      })
      // Deleting a site (handles the successful case)
      .addCase(deleteSite.fulfilled, (state, action: PayloadAction<number>) => {
        state.operationStatus = "succeeded";
        // The payload is the `siteId` we returned from the thunk.
        // `filter` creates a new array without the deleted site.
        state.sites = state.sites.filter((s) => s.id !== action.payload);
      });
  },
});

// --- SECTION 5: EXPORTS ---

// Export the synchronous action creator
export const { resetOperationStatus } = sitesSlice.actions;

// Export the reducer to be added to the store
export default sitesSlice.reducer;

// Export selectors to provide read-only access to the state from components.
// This encapsulates the shape of the state, so if it changes, we only
// have to update the selector here, not in every component.
export const selectAllSites = (state: RootState) => state.sites.sites;
export const selectSitesStatus = (state: RootState) => state.sites.status;
export const selectSitesError = (state: RootState) => state.sites.error;
export const selectSiteById = (state: RootState, siteId: number) =>
  state.sites.sites.find((s) => s.id === siteId);
export const selectSiteOperationStatus = (state: RootState) =>
  state.sites.operationStatus;
export const selectSiteOperationError = (state: RootState) =>
  state.sites.operationError;
